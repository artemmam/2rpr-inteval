import sympy as sym
import numpy as np
from mpmath import iv
import interval as ival
from mpmath import iv
import matplotlib.pyplot as plt
import matplotlib.patches as matpatch
from descartes.patch import PolygonPatch
from shapely.ops import cascaded_union, polygonize
from matplotlib.patches import Circle
from matplotlib.patches import Rectangle
import shapely.geometry as sg
from descartes.patch import PolygonPatch
import descartes


#%matplotlib inline
"""2RPR_interval.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oaJvPPCq4w_5SB8OPsqT-XtmopULyLd1
"""

# Commented out IPython magic to ensure Python compatibility.

import interval as ival

"""### ДАННЫЕ
Матрица $F(u, v)$ - система кинематических уравнений заданного робота
В данном случае $u = (\textbf{u1}, \textbf{u2})$ - интервальный вектор выходных данных,  $v = (\textbf{v1}, \textbf{v2})$ - интервальный вектор выходных данных

### АЛГОРИТМ
1) Рассчитать $\varLambda = (mid(F_v(\textbf{u}, \textbf{v})))^{-1}$

2) Рассчитать $G(\textbf{u}, \textbf{v}) [матрица интервалов] = v [вектор-столбец] - \varLambda [матрица чисел] \cdot F(\textbf{u}, \textbf{v})[матрица интервалов]$

3) Проверить $G(\textbf{u}, \textbf{v}) [матрица интервалов] \leq G(\textbf{u}, c)[матрица интервалов] + G_v(\textbf{u}, \textbf{v})[матрица интервалов] \cdot (\textbf{v} - c)[вектор-столбец]$
"""

def derive_matrix(G):
    Gv1 = sym.diff(G, v1)
    Gv2 = sym.diff(G, v2)
    Gv = sym.Matrix([Gv1, Gv2])
    Gv = Gv.reshape(2, 2)
    return(Gv)

d = 1# Расстояние между штангами, положим его константой и не будем учитывать в символьной записи
v1, v2, u1, u2 = sym.symbols('v1, v2, u1, u2')

F = sym.Matrix([[v1**2 - u1**2 - u2**2], [v2**2 - (u1 - d)**2 - u2**2]])
F

Fv = derive_matrix(F)
Fv

V = sym.Matrix([[v1], [v2]])
V

"""### $\varLambda$"""

lam = Fv**(-1)
v1mid, v2mid = sym.symbols('v1mid, v2mid')
lam = lam.subs([(v1, v1mid), (v2, v2mid)])
print(lam)

"""$G(\textbf{u}, \textbf{v})$"""

G = V - lam*F
G

"""$G(\textbf{u}, c) + G_v(\textbf{u}, \textbf{v}) \cdot (\textbf{v} - c)$"""

Gv = derive_matrix(G)
Gv

c = sym.Matrix([[v1mid], [v2mid]])
V_c = V - c
V_c

Gright = G.subs([(v1, v1mid), (v2, v2mid)]) + Gv * V_c
Gright

Gright_lamb = sym.lambdify([u1, u2, v1, v2, v1mid, v2mid], Gright)

Gright_lamb_no_Kr = sym.lambdify([u1, u2, v1, v2, v1mid, v2mid], G)

def draw_and_compute(l1_l, l2_l, l1_h, l2_h, d, l1, l2):# процедура отрисовки 
    Ax=[]
    Ay=[]
    if (l1_l<l1_h) and (l2_l<l2_h):
        l1_l+=0.00000000000001
        l2_l+=0.00000000000001
        fig, ax = plt.subplots(figsize=(8, 8))
        x_min, y_min, x_max, y_max=l1-1, l1-1, l2+1, l2+1
        ax.set_xlim([x_min, x_max])
        ax.set_ylim([y_min, y_max])
        a = sg.Point(0,0).buffer(l1_l)# задаём оркужности через shapely, чтобы построить пересечение колец и найти площадь пересечения
        b = sg.Point(0,0).buffer(l1_h)
        c = sg.Point(d,0).buffer(l2_l)
        e = sg.Point(d,0).buffer(l2_h)
        ab=b.difference(a)# строим кольца из большой и малой окружности
        cd=e.difference(c)
        middle = ab.intersection(cd)
        circle1 = Circle((0, 0), radius=l1_l, fill=False, color='r')# задаём окружности через matplotlib
        circle2 = Circle((0, 0), radius=l1_h, fill=False, color='r')
        circle3 = Circle((d, 0), radius=l2_l, fill=False, color='b')
        circle4 = Circle((d, 0), radius=l2_h, fill=False, color='b')
        rect1=Rectangle([l1, l1], abs(l1) + abs(l2), abs(l1) + abs(l2), fill=False, color='g', linewidth=2.0)
        ax.add_patch(descartes.PolygonPatch(middle, fc='b', ec='k', alpha=0.2))# отрисовываем       
        ax.add_patch(circle1)
        ax.add_patch(circle2)
        ax.add_patch(circle3)
        ax.add_patch(circle4)
        ax.add_patch(rect1)
       # ax.grid()
        ax.axes.set_aspect('equal')
        for i in range(len(area_points_X_l)):
            rect1=Rectangle([area_points_X_l[i], area_points_Y_l[i]],area_points_X_r[i] - area_points_X_l[i], 
                            area_points_Y_r[i] - area_points_Y_l[i], fill=True, fc='red', color='g', linewidth=1.0, alpha=0.5)
            ax.add_patch(rect1)
        for i in range(len(border_points_X_l)):
            rect2=Rectangle([border_points_X_l[i], border_points_Y_l[i]],border_points_X_r[i] - border_points_X_l[i], 
                            border_points_Y_r[i] - border_points_Y_l[i], fill=True, fc='black', color='yellow', linewidth=1.0, alpha=0.5)
            ax.add_patch(rect2)
    else:
        print('Неверные данные')

def check_Box(u1, u2):#базовый алгоритм с исходными L1 и L2
  v1 = ival.Interval([L1, L2])
  v2 = ival.Interval([L1, L2])
  for k in range(10):
              v1mid = v1.mid()
              v2mid = v2.mid()
              A = Gright_lamb(u1, u2, v1, v2, v1mid, v2mid)
              if (A[0][0].isIn(v1)) and (A[1][0].isIn(v2)):
                  return 0
                  break
              if k == 9:
                return 1
              try:
                v1.intersec(A[0][0])
                v2.intersec(A[1][0])
              except:
                break

def check_Box_no_Kr(u1, u2):# алгоритм с усиленной проверкой по 4 стороным
  check = True
  V1_bor = [ival.Interval([L1, L2]), ival.Interval([L2, L2]), ival.Interval([L1, L2]), ival.Interval([L1, L1])]
  V2_bor = [ival.Interval([L1, L1]), ival.Interval([L1, L2]), ival.Interval([L2, L2]), ival.Interval([L1, L2])]
  check = True
  for p in range(4):
    v1 = V1_bor[p]
    v2 = V2_bor[p]
    for k in range(10):
          v1mid = v1.mid()
          v2mid = v2.mid()
          v1_bor = ival.Interval([L1, L2])
          v2_bor = ival.Interval([L1, L2])
          A = Gright_lamb(u1, u2, v1, v2, v1mid, v2mid)
          if (A[0][0].isIn(v1_bor)) and (A[1][0].isIn(v2_bor)):
            check = True
            if p==3 and check == True:
              return 0
            break
          else:
            check = False
          try:
            v1_bor.intersec(A[0][0])
            v2_bor.intersec(A[1][0])
            v1 = v1_bor
            v2 = v2_bor
          except:
            break

def check_Box_branch_and_bounce(L1x, L2x, L1y, L2y):# алгоритм рекурсивного деления исходной области на более мелкие области
  Lx = L2x - L1x
  Ly = L2y - L1y
  if (stop<=Lx) and  (stop<=Ly):
    if Lx == max(Lx, Ly):
      v1_left = ival.Interval([L1x, (L1x + L2x)/2])
      v2_left = ival.Interval([L1y, L2y])
      v1_right = ival.Interval([(L1x + L2x)/2, L2x])
      v2_right = ival.Interval([L1y, L2y])
    else:
      v1_left = ival.Interval([L1x, L2x])
      v2_left = ival.Interval([(L1y + L2y)/2, L2y])
      v1_right = ival.Interval([L1x, L2x])
      v2_right = ival.Interval([L1y, (L1y + L2y)/2])
    for i in range(len(X)-1):
        for j in range(len(Y)-1):
          u1 = ival.Interval([X[i, j], X[i, j + 1]])
          u2 = ival.Interval([Y[i, j], Y[i + 1, j]])
          if (check_Box_custom_v(u1, u2, v1_left, v2_left) == 0) or (check_Box_custom_v(u1, u2, v1_right, v2_right) == 0):
            area_points_X_l.append(u1[0])
            area_points_X_r.append(u1[1])
            area_points_Y_l.append(u2[0])
            area_points_Y_r.append(u2[1])
    check_Box_branch_and_bounce(v1_left[0], v1_left[1], v2_left[0], v2_left[1])
    check_Box_branch_and_bounce(v1_right[0], v1_right[1], v2_right[0], v2_right[1])

def check_Box_custom_v(u1, u2, v1, v2):# базовый алгоритм для рекурсивного алгоритма
  v1_bor = ival.Interval([v1[0], v1[1]])
  v2_bor = ival.Interval([v2[0], v2[1]])
  for k in range(10):
    v1_fou = ival.Interval([L1, L2])
    v2_fou = ival.Interval([L1, L2])
    v1mid = v1_bor.mid()
    v2mid = v2_bor.mid()
    A = Gright_lamb(u1, u2, v1_bor, v2_bor, v1mid, v2mid)
    if (A[0][0].isIn(v1_bor)) and (A[1][0].isIn(v2_bor)):
      return 0
      break
    if k == 9:
      return 1
    try:
      v1_fou.intersec(A[0][0])
      v2_fou.intersec(A[1][0])
      v1_bor = v1_fou
      v2_bor = v2_fou
    except:
      return 2
      break

L1 = 3#Нижний диапазон
L2 = 15#верхний диапазон
N = 50#частота разбиения равномерной сетки
# Размер квадратной сетки
l1 = -L2
l2 = L2
#задаём сетку
X1 = np.linspace(l1, l2, N)
Y1 = np.linspace(l1, l2, N)
X, Y = np.meshgrid(X1, Y1)

"""### Стандартный алгоритм"""

area_points_X_l = []
area_points_X_r = []
area_points_Y_l = []
area_points_Y_r = []
border_points_X_l = []
border_points_X_r = []
border_points_Y_l = []
border_points_Y_r = []
for i in range(N-1):
      for j in range(N-1):
        u1 = ival.Interval([X[i, j], X[i, j + 1]])
        u2 = ival.Interval([Y[i, j], Y[i + 1, j]])
        if check_Box(u1, u2) == 0:
          area_points_X_l.append(X[i, j])
          area_points_X_r.append(X[i, j + 1])
          area_points_Y_l.append(Y[i, j])
          area_points_Y_r.append(Y[i+1, j])
        elif check_Box(u1, u2) == 1:
          border_points_X_l.append(X[i, j])
          border_points_X_r.append(X[i, j + 1])
          border_points_Y_l.append(Y[i, j])
          border_points_Y_r.append(Y[i+1, j])
draw_and_compute(L1, L1, L2, L2, d, l1, l2)

"""### Алгоритм с усилением"""

area_points_X_l = []
area_points_X_r = []
area_points_Y_l = []
area_points_Y_r = []
border_points_X_l = []
border_points_X_r = []
border_points_Y_l = []
border_points_Y_r = []
for i in range(N-1):
      for j in range(N-1):
        u1 = ival.Interval([X[i, j], X[i, j + 1]])
        u2 = ival.Interval([Y[i, j], Y[i + 1, j]])
        if check_Box_no_Kr(u1, u2) == 0:
          area_points_X_l.append(X[i, j])
          area_points_X_r.append(X[i, j + 1])
          area_points_Y_l.append(Y[i, j])
          area_points_Y_r.append(Y[i+1, j])
        if check_Box(u1, u2) == 0:
          area_points_X_l.append(X[i, j])
          area_points_X_r.append(X[i, j + 1])
          area_points_Y_l.append(Y[i, j])
          area_points_Y_r.append(Y[i+1, j])
        elif check_Box(u1, u2) == 1:
          border_points_X_l.append(X[i, j])
          border_points_X_r.append(X[i, j + 1])
          border_points_Y_l.append(Y[i, j])
          border_points_Y_r.append(Y[i+1, j])
draw_and_compute(L1, L1, L2, L2, d, l1, l2)

"""### Алгоритм с рекурсивным делением области равномерной сетки"""

area_points_X_l = []
area_points_X_r = []
area_points_Y_l = []
area_points_Y_r = []
border_points_X_l = []
border_points_X_r = []
border_points_Y_l = []
border_points_Y_r = []

l1 = -L2
l2 = L2
L1x = L1
L1y = L1
L2x = L2
L2y = L2
stop = (l2 - l1)/N# фиксируем длину сторону квадрата u как флаг для остановки
check_Box_branch_and_bounce(L1x, L2x, L1y, L2y)
draw_and_compute(L1, L1, L2, L2, d, l1, l2)